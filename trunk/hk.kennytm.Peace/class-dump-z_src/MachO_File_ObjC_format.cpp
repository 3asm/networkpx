/*

MachO_File_ObjC_Format.cpp ... Format ObjC types into string.

Copyright (C) 2009  KennyTM~

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "MachO_File_ObjC.h"
#include <string>
#include <cstring>
#include "string_util.h"
#include <pcre.h>
#include <cstdio>
#include <algorithm>
#include "combine_dependencies.h"

using namespace std;

static void print_banner (FILE* f) {
	fprintf(f,
			"/**\n"
			" * This header is generated by class-dump-z 0.1-11p.\n"
			" * class-dump-z is Copyright (C) 2009 by KennyTM~, licensed under GPLv3.\n"
			" */\n\n");
}

void MachO_File_ObjC::set_class_filter(const char* regexp) {
	if (m_class_filter != NULL) pcre_free(m_class_filter);
	if (m_class_filter_extra != NULL) pcre_free(m_class_filter_extra);
	
	const char* errStr = NULL;
	int erroffset;
	m_class_filter = pcre_compile(regexp, 0, &errStr, &erroffset, NULL);
	if (m_class_filter != NULL)
		m_class_filter_extra = pcre_study(m_class_filter, 0, &errStr);
	if (errStr != NULL)
		fprintf(stderr, "Warning: Encountered error while parsing RegExp pattern '%s' at offset %d: %s.\n", regexp, erroffset, errStr);
}

void MachO_File_ObjC::set_method_filter(const char* regexp) {
	if (m_method_filter != NULL) pcre_free(m_method_filter);
	if (m_method_filter_extra != NULL) pcre_free(m_method_filter_extra);
	
	const char* errStr = NULL;
	int erroffset;
	m_method_filter = pcre_compile(regexp, 0, &errStr, &erroffset, NULL);
	if (m_method_filter != NULL)
		m_method_filter_extra = pcre_study(m_method_filter, 0, &errStr);
	if (errStr != NULL)
		fprintf(stderr, "Warning: Encountered error while parsing RegExp pattern '%s' at offset %d: %s.\n", regexp, erroffset, errStr);
}

bool MachO_File_ObjC::name_killable(const char* name, size_t length, bool check_kill_prefix) const throw() {
	if (m_class_filter != NULL)
		if (0 != pcre_exec(m_class_filter, m_class_filter_extra, name, length, 0, 0, NULL, 0))
			return true;
	if (check_kill_prefix)
		for (vector<string>::const_iterator kit = m_kill_prefix.begin(); kit != m_kill_prefix.end(); ++ kit)
			if (!kit->empty())
				if (strncmp(name+strspn(name, "_"), kit->c_str(), kit->size()) == 0)
					return true;
	return false;
}



struct Method_AlphabeticSorter {
	const vector<MachO_File_ObjC::Method>& v;
	Method_AlphabeticSorter(const vector<MachO_File_ObjC::Method>& v_) : v(v_) {}
	
	bool operator() (unsigned a, unsigned b) { return strcmp(v[a].raw_name, v[b].raw_name) < 0; }
};

struct Property_AlphabeticSorter {
	const vector<MachO_File_ObjC::Property>& v;
	Property_AlphabeticSorter(const vector<MachO_File_ObjC::Property>& v_) : v(v_) {}
	
	bool operator() (unsigned a, unsigned b) { return v[a].name < v[b].name; }
};

string MachO_File_ObjC::Property::format(const ObjCTypeRecord& record, const MachO_File_ObjC& self, bool print_method_addresses, bool print_comments) const throw() {
	if (self.m_method_filter != NULL)
		if (0 != pcre_exec(self.m_method_filter, self.m_method_filter_extra, name.c_str(), name.size(), 0, 0, NULL, 0))
			return "";
	
	string res = "@property(";
	if (readonly)
		res += "readonly, ";
	if (copy)
		res += "copy";
	else if (retain)
		res += "retain";
	else
		res += "assign";
	if (nonatomic)
		res += ", nonatomic";
	if (has_getter) {
		res += ", getter=";
		res += getter;
	}
	if (has_setter) {
		res += ", setter=";
		res += setter;
	}
	res += ") ";
	if (gc_strength == GC_Strong)
		res += "__strong ";
	else if (gc_strength == GC_Weak)
		res += "__weak ";
	res += record.format(type, name);
	res.push_back(';');
	
	bool printed_double_slash = false;
	if (print_method_addresses) {
		if (getter_vm_address != 0 || setter_vm_address != 0) {
			printed_double_slash = true;
			res += "\t// ";
			if (getter_vm_address != 0) res += numeric_format("G=0x%x; ", getter_vm_address);
			if (setter_vm_address != 0) res += numeric_format("S=0x%x; ", setter_vm_address);
		}
	}
	if (print_comments) {
		if (impl_method != IM_None) {
			if (!printed_double_slash)
				res += "\t// ";
			switch (impl_method) {
				case IM_Synthesized:
					res += "@synthesize";
					if (name != synthesized_to) {
						res.push_back('=');
						res += synthesized_to;
					}
					break;
				case IM_Dynamic:
					res += "@dynamic";
					break;
				case IM_Converted:
					res += "converted property";
					break;
				default:
					break;
			}
		}
	}
	
	res.push_back('\n');
	
	return res;
}

string MachO_File_ObjC::Method::format(const ObjCTypeRecord& record, const MachO_File_ObjC& self, bool print_method_addresses, bool print_comments) const throw() {
	if (!print_comments && propertize_status != PS_None)
		return "";
	
	if (self.m_method_filter != NULL)
		if (0 != pcre_exec(self.m_method_filter, self.m_method_filter_extra, raw_name, strlen(raw_name), 0, 0, NULL, 0))
			return "";
	
	string res;
	switch (propertize_status) {
		case PS_DeclaredGetter:
			res = "// declared property getter: ";
			break;
		case PS_DeclaredSetter:
			res = "// declared property setter: ";
			break;
		case PS_ConvertedGetter:
			res = "// converted property getter: ";
			break;
		case PS_ConvertedSetter:
			res = "// converted property setter: ";
			break;
		default:
			break;
	}
	
	if (is_class_method)
		res += "+(";
	else
		res += "-(";
	
	res += record.format(types[0], "");
	res.push_back(')');
	
	if (components.size() == 3) {
		res += raw_name;
		if (res[res.size()-1] == ']')
			res.erase(res.size()-1);
	} else {
		for (unsigned i = 3; i < components.size(); ++ i) {
			if (i != 3)
				res.push_back(' ');
			res += components[i];
			res += ":(";
			res += record.format(types[i], "");
			res.push_back(')');
			res += argname[i];
		}
	}
	res.push_back(';');
	
	if (print_method_addresses && vm_address != 0)
		res += numeric_format("\t// 0x%x", vm_address);
	
	res.push_back('\n');
	
	return res;
}

string MachO_File_ObjC::ClassType::format(const ObjCTypeRecord& record, const MachO_File_ObjC& self, bool print_method_addresses, bool print_comments, bool print_ivar_offsets, bool sort_methods_alphabetically, bool show_only_exported_classes) const throw() {
	if (self.name_killable(name, strlen(name), type != CT_Category)) {
		if (type != CT_Category || self.name_killable(superclass_name, strlen(superclass_name), false))
			return "";
	}
		
	
	bool all_methods_filtered = true;
	
	string res;
	
	if (attributes & RO_HIDDEN) {
		if (show_only_exported_classes)
			return "";
		if (attributes & RO_EXCEPTION)
			res += "__attribute__((visibility(\"hidden\"),objc_exception))\n";
		else
			res += "__attribute__((visibility(\"hidden\")))\n";
	} else if (attributes & RO_EXCEPTION) {
		res += "__attribute__((objc_exception))\n";
	}
	
	vector<unsigned> property_index_remap (properties.size());
	for (unsigned i = 0; i < property_index_remap.size(); ++ i)
		property_index_remap[i] = i;
	
	vector<unsigned> method_index_remap (methods.size());
	for (unsigned i = 0; i < method_index_remap.size(); ++ i)
		method_index_remap[i] = i;
	
	if (sort_methods_alphabetically) {
		sort(property_index_remap.begin(), property_index_remap.end(), Property_AlphabeticSorter(properties));
		sort(method_index_remap.begin(), method_index_remap.end(), Method_AlphabeticSorter(methods));
	}
	
	switch (type) {
		case CT_Class:
			res += "@interface ";
			res += name;
			if (superclass_name != NULL) {
				res += " : ";
				res += superclass_name;
			}
			break;
			
		case CT_Protocol:
			res += "@protocol ";
			res += name;
			break;
			
		case CT_Category:
			res += "@interface ";
			res += superclass_name;
			res += " (";
			res += name;
			res.push_back(')');
			break;
			
		default:
			res += numeric_format("@wtf_type%u ", type);
			break;
	}
	
	if (adopted_protocols.size() > 0) {
		res += " <";
		bool is_first = true;
		for (vector<unsigned>::const_iterator cit = adopted_protocols.begin(); cit != adopted_protocols.end(); ++ cit) {
			if (is_first)
				is_first = false;
			else
				res += ", ";
			res += self.ma_classes[*cit].name;
		}
		
		res.push_back('>');
	}
	
	if (type == CT_Class && self.m_method_filter == NULL) {
		res += " {\n";
		for (vector<Ivar>::const_iterator cit = ivars.begin(); cit != ivars.end(); ++ cit) {
			res += record.format(cit->type, cit->name, 1);
			res.push_back(';');
			if (print_ivar_offsets) {
				char offset_string[32];
				snprintf(offset_string, 32, "\t// %u = 0x%x", cit->offset, cit->offset);
				res += offset_string;
			}
			res.push_back('\n');
		}
		res.push_back('}');
	}
	
	res.push_back('\n');
	
	for (vector<unsigned>::const_iterator cit = property_index_remap.begin(); cit != property_index_remap.end(); ++ cit) {
		string formatted_property = properties[*cit].format(record, self, print_method_addresses, print_comments);
		if (!formatted_property.empty()) {
			all_methods_filtered = false;
			res += formatted_property;
		}
	}
	
	bool is_optional = false;
	for (vector<unsigned>::const_iterator cit = method_index_remap.begin(); cit != method_index_remap.end(); ++ cit) {
		const Method& method = methods[*cit];
		if (method.optional != is_optional) {
			is_optional = method.optional;
			res += is_optional ? "@optional\n" : "@required\n";
		}
		string formatted_method = method.format(record, self, print_method_addresses, print_comments);
		if (!formatted_method.empty()) {
			all_methods_filtered = false;
			res += formatted_method;
		}
	}
	
	if (all_methods_filtered && self.m_method_filter != NULL)
		return "";
	
	res += "@end\n\n";
	
	return res;
}

#pragma mark -

bool mfoc_AlphabeticSorter(const MachO_File_ObjC::ClassType* a, const MachO_File_ObjC::ClassType* b) throw() {
	if (a->type == MachO_File_ObjC::ClassType::CT_Protocol && b->type != MachO_File_ObjC::ClassType::CT_Protocol)
		return true;
	else if (a->type != MachO_File_ObjC::ClassType::CT_Protocol && b->type == MachO_File_ObjC::ClassType::CT_Protocol)
		return false;
	
	const char* a_major = a->type == MachO_File_ObjC::ClassType::CT_Category ? a->superclass_name : a->name;
	const char* b_major = b->type == MachO_File_ObjC::ClassType::CT_Category ? b->superclass_name : b->name;
	const char* a_minor = a->type == MachO_File_ObjC::ClassType::CT_Category ? a->name : NULL;
	const char* b_minor = b->type == MachO_File_ObjC::ClassType::CT_Category ? b->name : NULL;
	
	int res = strcmp(a_major, b_major);
	if (res < 0)
		return true;
	else if (res > 0)
		return false;
	
	if (a_minor == NULL)
		return true;
	else if (b_minor == NULL)
		return false;
	
	res = strcmp(a_minor, b_minor);
	if (res < 0)
		return true;
	else
		return false;
}

void MachO_File_ObjC::print_class_type(SortBy sort_by, bool print_method_addresses, bool print_comments, bool print_ivar_offsets, bool sort_methods_alphabetically, bool show_only_exported_classes) const throw() {	
	switch (sort_by) {
		default:
			for (vector<ClassType>::const_iterator cit = ma_classes.begin(); cit != ma_classes.end(); ++ cit)
				printf("%s", cit->format(m_record, *this, print_method_addresses, print_comments, print_ivar_offsets, sort_methods_alphabetically, show_only_exported_classes).c_str());
			break;
		case SB_Alphabetic: {
			vector<const ClassType*> remap;
			remap.reserve(ma_classes.size());
			for (vector<ClassType>::const_iterator cit = ma_classes.begin(); cit != ma_classes.end(); ++ cit)
				remap.push_back(&*cit);
			sort(remap.begin(), remap.end(), mfoc_AlphabeticSorter);
			
			for (vector<const ClassType*>::const_iterator cit = remap.begin(); cit != remap.end(); ++ cit)
				printf("%s", (*cit)->format(m_record, *this, print_method_addresses, print_comments, print_ivar_offsets, sort_methods_alphabetically, show_only_exported_classes).c_str());
			break;
		}
	}
}

void MachO_File_ObjC::print_struct_declaration(SortBy sort_by) const throw() {
	print_banner(stdout);
	
	vector<ObjCTypeRecord::TypeIndex> public_struct_types = m_record.all_public_struct_types();
	if (sort_by == SB_Alphabetic)
		m_record.sort_alphabetically(public_struct_types);
	
	for (vector<ObjCTypeRecord::TypeIndex>::const_iterator cit = public_struct_types.begin(); cit != public_struct_types.end(); ++ cit) {
		const string& name = m_record.name_of_type(*cit);
		if (!name_killable(name.c_str(), name.size(), true))		
			printf("%s;\n\n", m_record.format(*cit, "", 0, true).c_str());
	}
}

namespace {
	struct Header {
		bool include_common;
		string struct_declarations;
		string declaration;
		tr1::unordered_map<ObjCTypeRecord::TypeIndex, ObjCTypeRecord::EdgeStrength> dependencies;
	};
}

void MachO_File_ObjC::write_header_files(const char* filename, bool print_method_addresses, bool print_comments, bool print_ivar_offsets, bool sort_methods_alphabetically, bool show_only_exported_classes) const throw() {
	vector<ObjCTypeRecord::TypeIndex> public_struct_types = m_record.all_public_struct_types();
	tr1::unordered_map<string, Header> headers;
	
	// Filter out those structs not matching the regexp or having specified prefix.
	bool need_killer_check = m_class_filter != NULL || !m_kill_prefix.empty();
	if (need_killer_check) {
		for (int i = public_struct_types.size()-1; i >= 0; -- i) {
			ObjCTypeRecord::TypeIndex idx = public_struct_types[i];
			const string& name = m_record.name_of_type(idx);
			if (name_killable(name.c_str(), name.size(), true))
				public_struct_types.erase(public_struct_types.begin() + i);
		}
	}
	
	// Distribute each class into files. 
	for (vector<ClassType>::const_iterator cit = ma_classes.begin(); cit != ma_classes.end(); ++ cit) {
		Header h;
		h.declaration = cit->format(m_record, *this, print_method_addresses, print_comments, print_ivar_offsets, sort_methods_alphabetically, show_only_exported_classes);
		// we still need to pay lip service to create an empty file for the filtered types if someone else it going to include us.
		if (!h.declaration.empty() || m_record.link_count(cit->type_index, true) > 0) {
			const tr1::unordered_map<ObjCTypeRecord::TypeIndex, ObjCTypeRecord::EdgeStrength>* dep = m_record.dependencies(cit->type_index);
			if (dep != NULL)
				h.dependencies = *dep;
			string file_name = cit->type == ClassType::CT_Category ? cit->superclass_name : cit->name;
			pair<tr1::unordered_map<string, Header>::iterator, bool> res = headers.insert(pair<string, Header>(file_name, h));
			if (!res.second) {
				res.first->second.declaration += h.declaration;
				combine_dependencies(res.first->second.dependencies, h.dependencies);
			}
		}
	}
	
	// TODO: pull out all structs which k_in = 1 into the header file.
	
	// Write the aggregation file first.
	const char* self_filename = self_path() ?: filename;
	const char* last_component = strrchr(self_filename, '/') ?: self_filename;
	if (*last_component == '/') ++ last_component;
	const char* dot_position = strrchr(last_component, '.');
	string aggr_filename = dot_position == NULL ? last_component : string(last_component, dot_position);
	
	FILE* f_aggr = fopen((aggr_filename + ".h").c_str(), "wt");
	print_banner(f_aggr);
	fprintf(f_aggr, "#import \"%s-Structs.h\"\n", aggr_filename.c_str());
	for (tr1::unordered_map<string, Header>::const_iterator hit = headers.begin(); hit != headers.end(); ++ hit) {
		fprintf(f_aggr, "#import \"%s.h\"\n", hit->first.c_str());
	}
	fclose(f_aggr);
	
	// Print the structs.
	FILE* f_structs = fopen((aggr_filename + "-Structs.h").c_str(), "wt");
	print_banner(f_structs);
	fprintf(f_structs, "%s\n", m_record.format_structs_with_forward_declarations(public_struct_types).c_str());
	fclose(f_structs);
	
	// Now print to each file.
	vector<ObjCTypeRecord::TypeIndex> weak_dependencies;
	tr1::unordered_set<string> already_included;

	for (tr1::unordered_map<string, Header>::const_iterator hit = headers.begin(); hit != headers.end(); ++ hit) {
		string cur_filename = hit->first;
		cur_filename += ".h";
		FILE* f = fopen(cur_filename.c_str(), "wt");
		print_banner(f);
		
		bool include_structs = true;
		weak_dependencies.clear();
		already_included.clear();
		// Write imports.
		for (tr1::unordered_map<ObjCTypeRecord::TypeIndex, ObjCTypeRecord::EdgeStrength>::const_iterator dit = hit->second.dependencies.begin(); dit != hit->second.dependencies.end(); ++ dit) {
			if (m_record.is_struct_type(dit->first)) {
				if (include_structs) {
					include_structs = false;
					fprintf(f, "#import \"%s-Structs.h\"\n", aggr_filename.c_str());
				}
			} else if (dit->second == ObjCTypeRecord::ES_Strong) {
				if (m_record.is_external_type(dit->first)) {
					tr1::unordered_map<ObjCTypeRecord::TypeIndex, string>::const_iterator lib_it = ma_include_paths.find(dit->first);
					if (lib_it != ma_include_paths.end()) {
						string lib_inc_path = lib_it->second;
						if (lib_inc_path[lib_inc_path.size()-1] == '/') {
							lib_inc_path += m_record.name_of_type(dit->first);
							lib_inc_path += ".h";
						}
						if (already_included.find(lib_inc_path) == already_included.end()) {
							fprintf(f, "#import <%s>\n", lib_inc_path.c_str());
							already_included.insert(lib_inc_path);
						}
					} else
						fprintf(f, "#import <%s.h> // Unknown library\n", m_record.name_of_type(dit->first).c_str());
				} else
					fprintf(f, "#import \"%s.h\"\n", m_record.name_of_type(dit->first).c_str());
			} else if (dit->second == ObjCTypeRecord::ES_Weak)
				weak_dependencies.push_back(dit->first);
		}
		
		fprintf(f, "\n%s", m_record.format_forward_declaration(weak_dependencies).c_str());
		fprintf(f, "\n%s", hit->second.declaration.c_str());
		fclose(f);
	}
}
