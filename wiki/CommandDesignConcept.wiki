#summary Design concept for a new iPhone application, ⌘
#labels Phase-Design

= Introduction =

⌘ (Command) is a proposed !MobileSubstrate-based application to solve issue 10 and allows copying from static labels. It will be independent of iKeyEx, but I'll provide this app alongside ℏClipboard.

Like iKeyEx, ⌘ will be divided into two parts: the framework part "libcommandlets.dylib" and the hooker part "UIHooker-Command.dylib". Users should be allowed to add functionality, called *⌘lets*, to ⌘ like iKeyEx.

= User Interface and Interaction =

For text fields, ⌘ will add !MagicPad-style selection. After the selection there will be a "⌘ button" next to it.

http://xae.xanga.com/76ff375630532230973774/w182066554.png

The "⌘ button" should also show when double tapping on an empty place.

  Alternate gesture to activate ⌘ would be long hold, but I don't like that because I will long hold to ensure I've clicked the right position.

Clicking on it shows an action menu.

http://x04.xanga.com/a78f065038333230974391/w182067085.png

For static labels, selection is difficult to implement, so ⌘ would probably not support it. But a hook will still be installed so that the action menu will be called up when the user double/triple tap on it.

== Preferences ==

Some people may want to full-fledged extension, while some people just need a no-fringe copy & paste. The ⌘lets should be allowed to rearranged and enabled/disabled by users.

In the Preferences, there will be an additional item "⌘ (Command)" that allows rearranging and regrouping ⌘lets.  

Besides rearrangement, users should also be allowed to set whether to enable ⌘ and the activation method.

= File Structure =

⌘'s file structure would be like this:

{{{
/
 Library/
  MobileSubstrate/
   DynamicLibraries/
    UIHooker-Command.dylib
    UIHooker-Command.plist
 System/
  Library/
   PreferenceBundles/
    CommandPreferences.bundle/
     <whatever it should be here>
 usr/
  lib/
   libcommandlets.dylib
 var/
  mobile/
   Library/
    Commandlets/
     CommandletsPreferences.plist
     cut.plist
     copy.plist
     paste.plist
     google.plist
     ...
     clipboard.bundle
     google.sh
     ...
     en.lproj/
      _default.strings
      cut.strings
      ...
     es.lproj/ ...
     ja.lproj/ ...
     ...
}}}

== ⌘let plist format ==

⌘lets will be specified through a property list. The content is like this:

{{{
# for paste.plist
 {
   title = "Paste";
   bin = "clipboard.bundle";
   type = "lib";
   call = "pasteEntry";
   availableWhenEmpty = 1;
 }
# for google.plist
 {
   title = "Google";
   bin = "google.sh";
   type = "exec";
   app = "com.apple.MobileSafari";
 }
}}}

|| *Key* || Meaning || Default value ||
|| title || The ⌘let's display name || (file name) ||
|| bin || The library, executable or shell script that will be used when user clicks on the ⌘let's button. || (file name)`.sh` ||
|| type || Equals `lib` if _bin_ is treated as a library, or `exec` if treated as executable or shell script. || `exec` ||
|| app ||  The application that the ⌘let will launch. If the current application is different from the specified one, the button shall appear in red, to indicate that the current program will quit. || "" ||
|| availableWhenEmpty || Whether the ⌘let will be available even if the selection is empty. || 0 ||
|| call || When _type_ is `lib`, the function name to call. || (file name) ||

== ⌘let as a `lib` ==

When the ⌘let is run as a library, the function with symbol specified in _call_ will be called.

That function must have signature
{{{
CMLFurtherAction run (NSString**                 pSelectedContent,
                      NSRange                    selectedRange,
                      NSObject<UIKeyboardInput>* target,
                      NSDictionary*              cmdletParams);
}}}

You can change the selected string while the program runs. If you do so, you _must_ release the old string and retain the new string, like this:
{{{
...
[*pSelectedContent release];
*pSelectedContent = [[NSString alloc] initWithString:@"new content"];
...
}}}

_target_ may be nil if the ⌘let is invoked programmatically.

_pSelectedContent_ should never point to nil. If the ⌘let is invoked from an empty selection, _pSelectedContent_ will contain the whole text field. Nevertheless, replacing the content in this situation only inserts text at the cursor, instead of replacing the whole string. You can check `(selectedRange.length == 0)` to see if the selection is actually empty. To force selecting the whole string, set the flag `CMLActionSelectAllNow` in the returned value as discussed below.

`CMLFurtherAction` is an enum indicated any further action to do. It has no effect (except for `CMLActionShowMenu`) if the target is static text. Anything resulting in a nonzero range in a DOM element will be invisible.
|| *value* || *meaning* ||
|| CMLActionDefault = 0 || Default: Update selection to surround new text ||
|| CMLActionCollapseToStart || Collapse selection to the beginning. ||
|| CMLActionCollapseToEnd || Collapse selection to the end. ||
|| CMLActionCollapseToOldEnd || Collapse selection to the end before text is replaced. ||
|| CMLActionReuseOldSelection || Reuse the old selection. ||
|| CMLActionMoveToBeginning || Set the selection to the start of text field. ||
|| CMLActionMoveToEnding || Set the selection to the end of text field. ||
|| CMLActionSelectAll || Select the whole text field. ||
|| CMLActionSelectToBeginningFromStart || Select to beginning from start. ||
|| CMLActionSelectToBeginningFromEnd || Select to beginning from end. ||
|| CMLActionSelectToEndingFromStart || Select to ending from start. ||
|| CMLActionSelectToEndingFromEnd || Select to ending from end. ||
|| CMLActionAnchorAtStart = 64 || Anchor the selection to the start point of the new selection. Subsequent movements in the text field will be interpreted as changing end point of selection, instead of moving the cursor, until another ⌘let is called. ||
|| CMLActionAnchorAtEnd = 128 || Anchor the selection to the end point of the new selection. ||
|| CMLActionShowMenu = 4096 || Show the action menu. ||
|| CMLActionSelectAllNow = 8192 || Select the whole text field now, before text replacing begins. ||

`CMLActionShowMenu`, `CMLActionSelectAllNow` and `CMLActionAnchor`_xxx_ can be combined with the rest of the actions.

If the ⌘let is a lib, the calling will be *blocking*, meaning the active application cannot continue until the ⌘let function finishes.

== ⌘let as an `exec` ==

If _run_ is declared as an `exec`, its `main()` will be called with these arguments:

|| `argv[1]` || The selected string ||
|| `argv[2]` || The starting location of selected range ||
|| `argv[3]` || The length of selected range ||
|| `argv[4]` || The whole string in the active text field ||

All of these are converted to a UTF8 string. 

An exec ⌘let *cannot* return or change any arguments. Also, the call can be *non-blocking*, i.e. the program flow can continue without waiting the ⌘let to finish.

  But we need to check if `system()`, `execl()`, etc. is allowed in sandboxed applications.

== Localization ==

⌘lets can provide localizations in the `(lang code).lproj` files as usual. The specific localizations should be named as `(file name).strings`

One particular attribute that should be localized is the _title_ key.

= libcommandlets.dylib API =

The following API shall be provided with libcommandlet.dylib:

{{{
#import <Foundation/Foundation.h>
#import <UIKit2/UIKeyboardInput.h>

typdef enum CMLFurtherAction { ... } CMLFurtherAction;

@interface CMLCommandlet
+(void)performFurtherAction:(CMLFurtherAction)theActions onTarget:(NSObject<UIKeyboardInput>*)target;
+(void)callCommandlet:(NSString*)cmdletName withTarget:(NSObject<UIKeyboardInput>*)target;
+(void)callCommandlet:(NNString*)cmdletName withString:(NSString*)selectedString;

+(void)interceptCommandlet:(NSString*)cmdletName toInstance:(NSObject*)interceptor action:(SEL)aSelector;
+(void)uninterceptCommandlet:(NSString*)cmdletName fromInstance:(NSObject*)interceptor action:(SEL)aSelector;

+(void)registerUndoManager:(CMLUndoManager*)manager;
+(CMLUndoManager*)undoManagerForTarget:(NSObject<UIKeyboardInput>*)target;
@end;
}}}

== ⌘let Interception ==

An application may want to intercept ⌘let calls, e.g. to integrate ⌘ into the application's custom copy and paste environment. 

The selector to parse must have this signature:

{{{
  -(BOOL)callbackWithCommandlet:(NSString*)cmdletName
                 selectedString:(NSString**)pSelectedString
                          range:(NSRange*)pSelectedRange
                         target:(NSObject<UIKeyboardInput>*)pTarget;
}}}

You can change any parameters in the interceptor. If you changes the selected string, remember to release the old instance and retain the new one.

The interceptor can return NO to cancel the propagation. The ⌘let and all subsequent interceptors will not be called if this returned NO.

A ⌘let can register multiple interceptors. They will be called in reverse registration order. 

As a good practice, remember to unintercept any interceptor before the program finishes.


== Undo/Redo Management ==
{{{
@interface CMLUndoManager {
  NSMutableArray* operations;
  NSUInteger undoLimit;
  NSUInteger currentStep;
  NSObject<UIKeyboardInput>* target;
  NSDate* lastMicromodTime;
  NSInterval micromodUpdateInterval;
}
@property(assign) NSUInteger undoLimit;
@property(assign,readonly,getter=isUndoable) BOOL undoable;
@property(assign,readonly,getter=isRedoable) BOOL redoable;
@property(assign,readonly) NSObject<UIKeyboardInput>* target;
@property(assign) NSInterval micromodUpdateInterval;
+(CMLUndoManager*)managerWithTarget:(NSObject<UIKeyboardInput>*)aTarget
+(CMLUndoManager*)managerWithTarget:(NSObject<UIKeyboardInput>*)aTarget undoLimit:(NSUInteger)limit;
+(CMLUndoManager*)managerWithTarget:(NSObject<UIKeyboardInput>*)aTarget undoLimit:(NSUInteger)limit micromodUpdateInterval:(NSInterval)interval;
-(id)initWithTarget:(NSObject<UIKeyboardInput>*)aTarget undoLimit:(NSUInteger)limit micromodUpdateInterval:(NSInterval)interval;;
-(void)dealloc;
-(void)undo;
-(void)redo;
-(void)setString:(NSString*)str;
-(void)appendString:(NSString*)str;
-(void)deleteCharactersCount:(NSUInteger)charsToDelete;
@end
}}}


You may use a `CMLUndoManager` to track changes to the text field when you want to provide undo/redo capability in your extension. Note that when using ⌘ alone without interception no undo managers will be used internally, that means ⌘ itself does not provide undo/redo capability.

  Later versions of ⌘ may provide built-in undo/redo by tracking keyboard input as well.

To use the undo manager, you have to first find the subview of the text field that actually sets ranges. Let's say it is stored in the variable _target_. Now call

{{{
  CMLUndoManager* myManager = [CMLUndoManager managerWithTarget:target];
  [CMLCommandlet registerUndoManager:target];
}}}

then any calls to ⌘lets that changes the input will be routed through `myManager` for tracking. Besides, you may want to track *micro-modifications* (micromod) such as entering a word or back-spacing a few characters. You can call

{{{
  [myManager appendString:@"word"];     // user typed "word".
  [myManager deleteCharactersCount:4];  // user deleted 4 characters
}}}

to track these micromods.

Whenever you want to undo 1 step, call
{{{
  [myManager undo];
}}}
and to redo call {{{[myManager redo]}}}. You should check if it is undoable/redoable with the `undoable` and `redoable` properties.

If an undo manager is registered with a target that is already held by another undo manager, the old one will be immediately disassociated and released. 

= Role of ℏClipboard =
As ⌘ can do a many similar job as ℏClipboard, after ⌘ is released the back-end of ℏClipboard will be pulled away, and the UI will be converted to a front-end of ⌘. 