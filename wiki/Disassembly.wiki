#summary Decompilation of some functions.

<wiki:toc/>

= UIKit =

== UIImage ==
=== ï¼¿UIImageRefAtPath ===
{{{
static CFStringRef const trustedPaths[] = {
	CFSTR("/System/"),
	CFSTR("/Applications/"),
	CFSTR("/Widgets/"),			// ???
	CFSTR("/Accessories/")		// ??? Do these paths exist at all???
};
static CGImageRef _UIImageRefAtPath(CFStringRef path, bool shouldCache, int* pOrientation) {
	CGImageRef retval = NULL;

	if (path != nil) {
		CFStringRef keys[2];
		keys[0] = kCGImageSourceShouldCache;
		keys[1] = CFSTR("kCGImageSourceSkipCRC");

		CFBooleanRef values[2];
		values[0] = shouldCache ? kCFBooleanTrue : kCFBooleanFalse;
		values[1] = kCFBooleanFalse;


		for (int i = 0; i < sizeof(trustedPaths)/sizeof(CFStringRef const); ++i) {
			if (CFStringHasPrefix(path, trustedPaths[i])) {
				values[1] = kCFBooleanTrue;
				break;
			}
		}

		CFDictionaryRef options;
		if (values[0] == kCFBooleanFalse && values[1] == kCFBooleanFalse) {
			options = NULL;
		} else {
			options = CFDictionaryCreate(
					kCFAllocatorDefault,
					keys,
					values,
					2,
					kCFTypeDictionaryKeyCallBacks,
					kCFTypeDictionaryValueCallBacks);
		}
		CGImageSourceRef isrc = CGImageSourceCreateWithFile(path, dict);
		
		if (isrc != NULL) {
			if (CGImageSourceGetCount(isrc) != 0) {
				retval = CGImageSourceCreateImageAtIndex(isrc, 0, options);
				if (pOrientation != NULL)
					*pOrientation = GetImageOrientation(isrc, 0);
			}
			CFRelease(isrc);
		}

		if (options != NULL)
			CFRelease(options);
	}

	return retval;
}
}}}

== UIControl ==
=== `-[UIControl mouseDown:]:` ===
{{{
-(void)mouseDown:(GSEventRef)event {
	if (![self shouldTrack])
		[super mouseDown:event];
	else {
		CGPoint startPoint = [self convertPoint:GSEventGetLocationInWindow(event) fromView:nil];
		self.tracking = [self beginTrackingAt:startPoint withEvent:event];
		if (self.tracking) {
			_controlFlags.touchInside = YES;
			_controlFlags.touchDragged = NO;
			_previousPoint = startPoint;
			if (!_controlFlags.dontHighlightOnTouchDown) {
				_downTime = CFAbsoluteTimeGetCurrent();
				self.highlighted = YES;
			}
			int clickCount = GSEventGetClickCount(event);
			[self _sendActionsForEventMask:(clickCount<=1 ? 1 : 2) withEvent:event];
		}
		[self _controlMouseDown:event];
	}
}
}}}

== UIWebDocumentView ==
=== `-[UIWebDocumentView(Interaction) calloutApproximateNode]` ===
{{{
-(void)calloutApproximateNode {
	UIWindow* window = self.window;
	UIView* calloutParent = [window contentView];
	UICalloutView* callout = [[self class] _calloutViewForWebView:self];
	if ([self->_delegate respondsToSelector:@selector(superviewForCalloutInWebView:)]) {
		calloutParent = [self->_delegate superviewForCalloutInWebView:self];
	}
	[calloutParent addSubview:callout];
	NSString* title = [self->_interaction.candidate calloutTitle];
	NSString* subtitle = [self->_interaction.candidate calloutSubtitle];
	if ([title length] == 0) {
		title = subtitle;
		subtitle = nil;
	}
	if ([self->_delegate respondsToSelector:@selector(webView:willShowCalloutWithTitle:andSubtitle:forElement:)]) {
		[self->_delegate webView:self willShowCalloutWithTitle:&title andSubtitle:&subtitle forElement:self->_interaction.candidate];
	}
	[callout setTitle:title];
	[callout setSubtitle:subtitle];
	CGPoint anchorPoint = [calloutParent convertPoint:self->_interaction.location fromView:self];
	CGRect boundaryRect = [calloutParent convertRect:[window convertDeviceToWindow:[self->_interaction.candidate calloutDeviceBoundaryForWebView:self]]
                                                fromView:window];
	[callout setAnchorPoint:anchorPoint boundaryRect:boundaryRect animate:YES];
}
}}}