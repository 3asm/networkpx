#summary Decompilation of some functions.

<wiki:toc />

= UIKit =

== UIImage ==
=== ï¼¿UIImageRefAtPath ===
{{{
static CFStringRef const trustedPaths[] = {
	CFSTR("/System/"),
	CFSTR("/Applications/"),
	CFSTR("/Widgets/"),			// ???
	CFSTR("/Accessories/")		// ??? Do these paths exist at all???
};
static CGImageRef _UIImageRefAtPath(CFStringRef path, bool shouldCache, int* pOrientation) {
	CGImageRef retval = NULL;

	if (path != nil) {
		CFStringRef keys[2];
		keys[0] = kCGImageSourceShouldCache;
		keys[1] = CFSTR("kCGImageSourceSkipCRC");

		CFBooleanRef values[2];
		values[0] = shouldCache ? kCFBooleanTrue : kCFBooleanFalse;
		values[1] = kCFBooleanFalse;


		for (int i = 0; i < sizeof(trustedPaths)/sizeof(CFStringRef const); ++i) {
			if (CFStringHasPrefix(path, trustedPaths[i])) {
				values[1] = kCFBooleanTrue;
				break;
			}
		}

		CFDictionaryRef options;
		if (values[0] == kCFBooleanFalse && values[1] == kCFBooleanFalse) {
			options = NULL;
		} else {
			options = CFDictionaryCreate(
					kCFAllocatorDefault,
					keys,
					values,
					2,
					kCFTypeDictionaryKeyCallBacks,
					kCFTypeDictionaryValueCallBacks);
		}
		CGImageSourceRef isrc = CGImageSourceCreateWithFile(path, dict);
		
		if (isrc != NULL) {
			if (CGImageSourceGetCount(isrc) != 0) {
				retval = CGImageSourceCreateImageAtIndex(isrc, 0, options);
				if (pOrientation != NULL)
					*pOrientation = GetImageOrientation(isrc, 0);
			}
			CFRelease(isrc);
		}

		if (options != NULL)
			CFRelease(options);
	}

	return retval;
}
}}}

== UIControl ==
=== `-[UIControl mouseDown:]:` ===
{{{
-(void)mouseDown:(GSEventRef)event {
	if (![self shouldTrack])
		[super mouseDown:event];
	else {
		CGPoint startPoint = [self convertPoint:GSEventGetLocationInWindow(event) fromView:nil];
		self.tracking = [self beginTrackingAt:startPoint withEvent:event];
		if (self.tracking) {
			_controlFlags.touchInside = YES;
			_controlFlags.touchDragged = NO;
			_previousPoint = startPoint;
			if (!_controlFlags.dontHighlightOnTouchDown) {
				_downTime = CFAbsoluteTimeGetCurrent();
				self.highlighted = YES;
			}
			int clickCount = GSEventGetClickCount(event);
			[self _sendActionsForEventMask:(clickCount<=1 ? 1 : 2) withEvent:event];
		}
		[self _controlMouseDown:event];
	}
}
}}}

== UIWebDocumentView ==
=== `-[UIWebDocumentView(Interaction) calloutApproximateNode]` ===
{{{
-(void)calloutApproximateNode {
	UIWindow* window = self.window;
	UIView* calloutParent = [window contentView];
	UICalloutView* callout = [[self class] _calloutViewForWebView:self];
	if ([self->_delegate respondsToSelector:@selector(superviewForCalloutInWebView:)]) {
		calloutParent = [self->_delegate superviewForCalloutInWebView:self];
	}
	[calloutParent addSubview:callout];
	NSString* title = [self->_interaction.element calloutTitle];
	NSString* subtitle = [self->_interaction.element calloutSubtitle];
	if ([title length] == 0) {
		title = subtitle;
		subtitle = nil;
	}
	if ([self->_delegate respondsToSelector:@selector(webView:willShowCalloutWithTitle:andSubtitle:forElement:)]) {
		[self->_delegate webView:self willShowCalloutWithTitle:&title andSubtitle:&subtitle forElement:self->_interaction.element];
	}
	[callout setTitle:title];
	[callout setSubtitle:subtitle];
	CGPoint anchorPoint = [calloutParent convertPoint:self->_interaction.location fromView:self];
	CGRect boundaryRect = [calloutParent convertRect:[window convertDeviceToWindow:[self->_interaction.element calloutDeviceBoundaryForWebView:self]]
                                                fromView:window];
	[callout setAnchorPoint:anchorPoint boundaryRect:boundaryRect animate:YES];
}
}}}

=== `-[UIWebDocumentView(InteractionPrivate) _showImageSheet]` ===
{{{
#define LOCALIZE(str) WebLocalizedString(&UIKitLocalizableStringsBundle, (str))
-(void)_showImageSheet {
	self->_interaction.imageSheet = [[UIModalView alloc] init];
	self->_interaction.imageSheet.alertSheetStyle = UIBarStyleDefault;
	self->_interaction.imageSheet.delegate = self;
	
	UIButton* saveImageButton = [self->_interaction.imageSheet _addButtonWithTitle:LOCALIZE("Save Image")];
	saveImageButton.tag = 1;

	if ([self->_interaction.delegate respondsToSelector:@selector(numberOfImagesToSaveForWebView:)]) {
		int imageCount = [self->_interaction.delegate numberOfImagesToSaveForWebView:self];
		if (imageCount > 1) {
			saveImageButton = [self->_interaction.imageSheet _addButtonWithTitle:[NSString stringWithFormat:LOCALIZE("Save N Images"), imageCount]];
			saveImageButton.tag = 2;
		}
	}

	if ([self->_interaction.element showsTapHighlight]) {
		UIButton* openLinkButton = [self->_interaction.imageSheet _addButtonWithTitle:LOCALIZE("Open Link")];
		openLinkButton.tag = 3;
		[self hideCalloutAndHighlight];
	}
	
	UIButton* cancelButton = [self->_interaction.imageSheet _addButtonWithTitle:LOCALIZE("Cancel")];
	cancelButton.tag = 4;
	self->_interaction.imageSheet.defaultButton = cancelButton;
	[self highlightApproximateNodeInverted:YES];

	UIWindow* actionShowView = self.window;
	if ([self->_interaction.delegate respondsToSelector:@selector(superviewForImageSheetForWebView:)]) {
		actionShowView = [self->_interaction.delegate superviewForImageSheetForWebView:self];
	}
	[self->_interaction.imageSheet presentSheetInView:actionShowView];

	if ([self->_interaction.delegate respondsToSelector:@selector(webView:didShowImageSheet:)]) {
		[self->_interaction.delegate webView:self didShowImageSheet:self->_interaction.imageSheet];
	}
}
#undef LOCALIZE
}}}

= !TextInput_ja =
== UIKeyboardLayoutQWERTY_ja_JP_landscape ==
=== `-[UIKeyboardLayoutQWERTY_ja_JP_landscape longPressAction]` ===
{{{
-(void)longPressAction {
	UIKeyDefinition* keyDef = [self activeKey];

	if (keyDef == nil)
		return;

	if (![self isLongPressedKey:keyDef])
		return;

	self->m_didLongPress = YES;

	if ([self downActionFlagsForKey:keyDef] < 0) {
		[self showPopupVariantsForKey:keyDef];
	} else
		[super longPressAction];
}
}}}

=== `-[UIKeyboardLayoutQWERTY_ja_JP_landscape showPopupVariantsForKey:]` ===
{{{
static UIColor* translucentBlackColor = nil;	// bb468;

// ...

-(void)showPopupVariantsForKey:(UIKeyDefinition*)keyDef {
	if (keyDef == NULL)
		return;
		
	if ([self downActionFlagsForKey:keyDef] >= 0) {
		[super showPopupVariantsForKey:keyDef];
		return;
	}

	if (translucentBlackColor == nil) {
		translucentBlackColor = [[UIColor alloc] initWithRed:0 green:0 blue:0 alpha:0.15f];
	}	

	[self->m_accentedKeyView removeFromSuperview];

	NSString* inputString = [self inputStringForKey:keyDef];
	UIKeyboardImpl* impl = [UIKeyboardImpl sharedInstance];
	
	NSDictionary* fullWidthVariants = UIKeyboardFullwidthVariants(inputString);
	if (fullWidthVariants == nil)
		return;

	[impl removeAutocorrectPrompt];
	[self deactivateActiveKeys];

	NSArray* strings = [fullWidthVariants objectForKey:@"Strings"];	// r4
	NSArray* keycaps = [fullWidthVariants objectForKey:@"Keycaps"];	// r8
	NSString* popup = [fullWidthVariants objectForKey:@"Popup"];	// r5

	if ( (keycaps == nil && strings == nil) || popup == nil )
		return;

	NSMutableArray* newStrings = [[strings mutableCopy] autorelease];
	[newStrings addObjectsFromArray:keycaps];

	self->m_accentedKeyView = [[UIAccentedCharacterView alloc] initWithFrame:keyDef->accent_frame
	                                                                variants:newStrings
	                                                               expansion:[popup isEqualToString:@"left"]
	                                                             orientation:[impl orientation]];
	[self addSubview:self->m_accentedKeyView];
	[self->m_accentedKeyView release];
	[self.window _setMouseDownView:self->m_accentedKeyView withEvent:nil];
}
}}}